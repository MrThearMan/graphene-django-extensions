{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Graphene Django Extensions \ud83d\udd17 pip install graphene-django-extensions Documentation : https://mrthearman.github.io/graphene-django-extensions/ Source Code : https://github.com/MrThearMan/graphene-django-extensions/ Contributing : https://github.com/MrThearMan/graphene-django-extensions/blob/main/CONTRIBUTING.md Extensions for writing GraphQL schemas with the graphene-django library with less boilerplate. The main features are: A new ObjectType DjangoNode , which: adds convenience methods for managing permissions for both the ObjectType and individual fields. adds a hook for adding filtering to both single items and lists returned by the ObjectType. adds convenience methods for creating Fields, ListFields, Nodes, and Connections for the ObjectType. adds filterset filters automatically to ListFields created for the ObjectType. automatically optimizes queries using graphene-django-query-optimizer . A new MutationType DjangoMutation , which: adds convenience methods for managing permissions. adds create , update operation with serializers and delete operations with optional validation hook. adds an option for custom model operations. makes updates fully partial by default. adds better error handling. A new ModelSerializer NestingModelSerializer , which: adds pre and post save handlers for creating or updating related entities from nested serializer fields, all within a single transaction to ensure atomicity. adds better handling of constraint integrity errors by finding violation_error_message from the constraint. adds get_or_default method for finding default values for field validation. A new FilterSet ModelFilterSet , which: changes the default filters for related fields to the custom IntChoiceFilter and IntMultipleChoiceFilter filters, which don't make database queries to check if the given primary keys for the filters actually correspond to existing rows for the database model. adds a custom ordering filter automatically to all subclasses, with the default pk filter. allows adding new ordering filters with the Meta.order_by attribute. order_by fields are converted to enums for better autocompletion in GraphiQL. allows combining multiple method filters with the Meta.combination_methods attribute.","title":"Home"},{"location":"#graphene-django-extensions","text":"pip install graphene-django-extensions Documentation : https://mrthearman.github.io/graphene-django-extensions/ Source Code : https://github.com/MrThearMan/graphene-django-extensions/ Contributing : https://github.com/MrThearMan/graphene-django-extensions/blob/main/CONTRIBUTING.md Extensions for writing GraphQL schemas with the graphene-django library with less boilerplate. The main features are: A new ObjectType DjangoNode , which: adds convenience methods for managing permissions for both the ObjectType and individual fields. adds a hook for adding filtering to both single items and lists returned by the ObjectType. adds convenience methods for creating Fields, ListFields, Nodes, and Connections for the ObjectType. adds filterset filters automatically to ListFields created for the ObjectType. automatically optimizes queries using graphene-django-query-optimizer . A new MutationType DjangoMutation , which: adds convenience methods for managing permissions. adds create , update operation with serializers and delete operations with optional validation hook. adds an option for custom model operations. makes updates fully partial by default. adds better error handling. A new ModelSerializer NestingModelSerializer , which: adds pre and post save handlers for creating or updating related entities from nested serializer fields, all within a single transaction to ensure atomicity. adds better handling of constraint integrity errors by finding violation_error_message from the constraint. adds get_or_default method for finding default values for field validation. A new FilterSet ModelFilterSet , which: changes the default filters for related fields to the custom IntChoiceFilter and IntMultipleChoiceFilter filters, which don't make database queries to check if the given primary keys for the filters actually correspond to existing rows for the database model. adds a custom ordering filter automatically to all subclasses, with the default pk filter. allows adding new ordering filters with the Meta.order_by attribute. order_by fields are converted to enums for better autocompletion in GraphiQL. allows combining multiple method filters with the Meta.combination_methods attribute.","title":"Graphene Django Extensions"},{"location":"filtering/","text":"Filtering \ud83d\udd17 ModelFilterSet \ud83d\udd17 A custom FilterSet class for optimizing the filtering of GraphQL queries. from graphene_django_extensions import ModelFilterSet from example.models import Example class ExampleFilterSet ( ModelFilterSet ): class Meta : model = Example fields = [ ... ] Extends django_filters.filterset.FilterSet and adds the following features: Automatically a order_by = CustomOrderingFilter(fields=[\"pk\"]) to the class for ordering the filterset. Changes the default filters for all relationships ( one-to-one , many-to-one , etc.) to not make a database queries to check if the filtered rows exists. Subclasses can be configured through the Meta -class. Here are the most useful options: Option Type Description model type[Model] Required. The model class for the filterset. fields list[str] or dict[str, list[str]] or __all__ Required. The fields to include in the node. If __all__ is used, all fields are included. order_by list[str] or list[tuple[str, str]] Optional. Ordering filters to add to the filterset. Can also add non-field orderings, or customize field orderings by adding a order_by_{field_name} method to the ModelFilterSet subclass. combination_methods list[str] Optional. Allows combining method filters so that they will use the same filter function. The combination method will always run, and its value will be a mapping of the field names of the combined filters to their values. CustomOrderingFilter \ud83d\udd17 Extends django_filters.filters.OrderingFilter by adding option for custom orderings by defining order_by_{name} functions on its subclasses or filtersets it is defined on. This filter is automatically added to ModelFilterSet subclasses, and its Meta.order_by can be used to add custom orderings. from graphene_django_extensions import ModelFilterSet class ExampleFilterSet ( ModelFilterSet ): class Meta : model = Example fields = [ ... ] order_by = [ \"name\" ] def order_by_name ( self , qs : QuerySet , desc : bool ) -> QuerySet : return qs . order_by ( \"-name\" if desc else \"name\" ) Additionally, the ordering choices are converted to GraphQL enums (e.g. \"name\" -> nameAsc & \"-name\" -> nameDesc ), which gives better autocomplete results in GraphiQL, and makes the available orderings more explicit. UserDefinedFilter \ud83d\udd17 A filter which allows users to define custom filtering rules for a set of predefined model fields. The idea is similar in concept to the GraphQL itself; allowing users to select which data they actually need vs. what has been predefined. from graphene_django_extensions.filters import ModelFilterSet , UserDefinedFilter class ExampleFilterSet ( ModelFilterSet ): filter = UserDefinedFilter ( model = Example , fields = [ \"name\" , \"number\" , \"email\" ], ) Given the above filter, the user can define the following filter: query { examples ( filter : { field : name , operation : CONTAINS , value : \"foo\" , } ) { edges { node { pk } } } } This creates a simple Q(name__contains=\"foo\") filter for the queryset. Notice that the field values are enums created from the defined fields in the UserDefinedFilter. If no fields are given, all fields from the given model can be filtered on. Related fields can also be added via the \"__\" lookup syntax. Filter aliases can be given by specifying a tuple of (\"field_lookup\", \"alias\") in the fields list. The model argument is mandatory, and is used to rename the filter input type after the field enum field has been added to it (in additions fetching the default fields if no fields are defined). Let's see a more complex example: query { examples ( filter : { operation : AND , operations : [ { operation : OR , operations : [ { field : name , operation : CONTAINS , value : \"foo\" , }, { field : email , operation : CONTAINS , value : \"foo\" , }, ], }, { operation : NOT , operations : [ { field : number , operation : LT , value : 10 , } ] }, ], } ) { edges { node { pk } } } } This configuration corresponds to (Q(name__contains=\"foo\") | Q(email__contains=\"foo\") & ~Q(number__lt=10)) . As the above example demonstrates, logical operations can also be used, allowing for complex filtering rules to be defined, which regular filter fields cannot do. EnumChoiceFilter & EnumMultipleChoiceFilter \ud83d\udd17 Custom fields for handling enums better in GraphQL filters. Using django_filters.ChoiceFilter causes the Enums to be converted to strings in GraphQL filters. This class uses GraphQL Enums instead, which gives better autocomplete results. IntegerChoiceFilter & IntegerMultipleChoiceFilter \ud83d\udd17 Allows plain integers as choices in GraphQL filters. Normally, integer enums are converted to string enums in GraphQL by prefixing them with A_ , but this filter allows using plain integers.","title":"Filtering"},{"location":"filtering/#filtering","text":"","title":"Filtering"},{"location":"filtering/#modelfilterset","text":"A custom FilterSet class for optimizing the filtering of GraphQL queries. from graphene_django_extensions import ModelFilterSet from example.models import Example class ExampleFilterSet ( ModelFilterSet ): class Meta : model = Example fields = [ ... ] Extends django_filters.filterset.FilterSet and adds the following features: Automatically a order_by = CustomOrderingFilter(fields=[\"pk\"]) to the class for ordering the filterset. Changes the default filters for all relationships ( one-to-one , many-to-one , etc.) to not make a database queries to check if the filtered rows exists. Subclasses can be configured through the Meta -class. Here are the most useful options: Option Type Description model type[Model] Required. The model class for the filterset. fields list[str] or dict[str, list[str]] or __all__ Required. The fields to include in the node. If __all__ is used, all fields are included. order_by list[str] or list[tuple[str, str]] Optional. Ordering filters to add to the filterset. Can also add non-field orderings, or customize field orderings by adding a order_by_{field_name} method to the ModelFilterSet subclass. combination_methods list[str] Optional. Allows combining method filters so that they will use the same filter function. The combination method will always run, and its value will be a mapping of the field names of the combined filters to their values.","title":"ModelFilterSet"},{"location":"filtering/#customorderingfilter","text":"Extends django_filters.filters.OrderingFilter by adding option for custom orderings by defining order_by_{name} functions on its subclasses or filtersets it is defined on. This filter is automatically added to ModelFilterSet subclasses, and its Meta.order_by can be used to add custom orderings. from graphene_django_extensions import ModelFilterSet class ExampleFilterSet ( ModelFilterSet ): class Meta : model = Example fields = [ ... ] order_by = [ \"name\" ] def order_by_name ( self , qs : QuerySet , desc : bool ) -> QuerySet : return qs . order_by ( \"-name\" if desc else \"name\" ) Additionally, the ordering choices are converted to GraphQL enums (e.g. \"name\" -> nameAsc & \"-name\" -> nameDesc ), which gives better autocomplete results in GraphiQL, and makes the available orderings more explicit.","title":"CustomOrderingFilter"},{"location":"filtering/#userdefinedfilter","text":"A filter which allows users to define custom filtering rules for a set of predefined model fields. The idea is similar in concept to the GraphQL itself; allowing users to select which data they actually need vs. what has been predefined. from graphene_django_extensions.filters import ModelFilterSet , UserDefinedFilter class ExampleFilterSet ( ModelFilterSet ): filter = UserDefinedFilter ( model = Example , fields = [ \"name\" , \"number\" , \"email\" ], ) Given the above filter, the user can define the following filter: query { examples ( filter : { field : name , operation : CONTAINS , value : \"foo\" , } ) { edges { node { pk } } } } This creates a simple Q(name__contains=\"foo\") filter for the queryset. Notice that the field values are enums created from the defined fields in the UserDefinedFilter. If no fields are given, all fields from the given model can be filtered on. Related fields can also be added via the \"__\" lookup syntax. Filter aliases can be given by specifying a tuple of (\"field_lookup\", \"alias\") in the fields list. The model argument is mandatory, and is used to rename the filter input type after the field enum field has been added to it (in additions fetching the default fields if no fields are defined). Let's see a more complex example: query { examples ( filter : { operation : AND , operations : [ { operation : OR , operations : [ { field : name , operation : CONTAINS , value : \"foo\" , }, { field : email , operation : CONTAINS , value : \"foo\" , }, ], }, { operation : NOT , operations : [ { field : number , operation : LT , value : 10 , } ] }, ], } ) { edges { node { pk } } } } This configuration corresponds to (Q(name__contains=\"foo\") | Q(email__contains=\"foo\") & ~Q(number__lt=10)) . As the above example demonstrates, logical operations can also be used, allowing for complex filtering rules to be defined, which regular filter fields cannot do.","title":"UserDefinedFilter"},{"location":"filtering/#enumchoicefilter-enummultiplechoicefilter","text":"Custom fields for handling enums better in GraphQL filters. Using django_filters.ChoiceFilter causes the Enums to be converted to strings in GraphQL filters. This class uses GraphQL Enums instead, which gives better autocomplete results.","title":"EnumChoiceFilter &amp; EnumMultipleChoiceFilter"},{"location":"filtering/#integerchoicefilter-integermultiplechoicefilter","text":"Allows plain integers as choices in GraphQL filters. Normally, integer enums are converted to string enums in GraphQL by prefixing them with A_ , but this filter allows using plain integers.","title":"IntegerChoiceFilter &amp; IntegerMultipleChoiceFilter"},{"location":"mutations/","text":"Mutations \ud83d\udd17 DjangoMutation \ud83d\udd17 Custom base class for GraphQL-mutations that are backed by a Django model. Has three subclasses: CreateMutation , UpdateMutation and DeleteMutation , which should cover most use cases, but custom mutations can also be created. from graphene_django_extensions import CreateMutation , UpdateMutation , DeleteMutation class ExampleCreateMutation ( CreateMutation ): class Meta : model = Example serializer_class = ExampleSerializer class ExampleUpdateMutation ( UpdateMutation ): class Meta : model = Example serializer_class = ExampleSerializer class ExampleDeleteMutation ( DeleteMutation ): class Meta : model = Example Adds the following features to all types that inherit it: For update operations, converts all fields to optional fields, enabling partial updates. Can add permission checks via permission classes. Converts and formats errors raised from serializers (also nested ones) into GraphQL errors. Checks for missing object types for nested model serializer fields to avoid nebulous import order errors. Permission errors \ud83d\udd17 If a permission check for a mutation fails, an error like this will be raised: { \"errors\" : [ { \"message\" : \"No permission to create.\" , \"path\" : [ \"createExample\" ], \"extensions\" : { \"code\" : \"CREATE_PERMISSION_DENIED\" }, \"locations\" : [{ \"line\" : 1 , \"column\" : 63 }] } ] } The message and code depends on the operation type, and can be changed using the following settings. Operation Message setting Message default Code setting Code default create CREATE_PERMISSION_ERROR_MESSAGE No permission to create. CREATE_PERMISSION_ERROR_CODE CREATE_PERMISSION_DENIED update UPDATE_PERMISSION_ERROR_MESSAGE No permission to update. UPDATE_PERMISSION_ERROR_CODE UPDATE_PERMISSION_DENIED delete DELETE_PERMISSION_ERROR_MESSAGE No permission to delete. DELETE_PERMISSION_ERROR_CODE DELETE_PERMISSION_DENIED custom MUTATION_PERMISSION_ERROR_MESSAGE No permission to mutate. MUTATION_PERMISSION_ERROR_CODE MUTATION_PERMISSION_DENIED More on permissions on the permissions page . Field level errors \ud83d\udd17 If a mutation serializer raises a ValidationError , the errors will be converted into a single GraphQL error with all the individual field error messages and codes included: { \"errors\" : [ { \"message\" : \"Mutation was unsuccessful.\" , \"path\" : [ \"createExample\" ], \"extensions\" : { \"code\" : \"MUTATION_VALIDATION_ERROR\" , \"errors\" : [ { \"field\" : \"number\" , \"message\" : \"Number must be positive.\" , \"code\" : \"invalid\" }, { \"field\" : \"number\" , \"message\" : \"Number must be an even.\" , \"code\" : \"\" }, { \"field\" : \"text\" , \"message\" : \"Text must be at least 10 characters long.\" , \"code\" : \"invalid\" } ] }, \"locations\" : [{ \"line\" : 1 , \"column\" : 63 }] } ] } If the error is raised from a nested serializer (when creating sub entities along with the parent entity, see NestingModelSerializer below), the field will include the dotted path to the sub entity where the field is located: { \"errors\" : [ { \"message\" : \"Mutation was unsuccessful.\" , \"path\" : [ \"createExample\" ], \"extensions\" : { \"code\" : \"MUTATION_VALIDATION_ERROR\" , \"errors\" : [ { \"field\" : \"subEntry.number\" , \"message\" : \"Number must be positive.\" , \"code\" : \"invalid\" } ] }, \"locations\" : [{ \"line\" : 1 , \"column\" : 63 }] } ] } The following options can be set in the Meta -class. Option Type Description model type[Model] Required (delete only). Model class for the model the operation is performed on. serializer_class type[ModelSerializer] Required (create and update only). The serializer used for the mutation. output_serializer_class type[ModelSerializer] Optional. The serializer used for the output data. If not set, serializer_class is used. Serializer fields are modified so that all fields are optional, enabling partial updates. permission_classes list[type[BasePermission]] Optional. Set permission classes for the mutation. Defaults to ( AllowAny ,). lookup_field str Optional. The field used for looking up the instance to be mutated. Defaults to the object's primary key, which is usually id . Note that the lookup_field attribute has to be available from the serializer's Meta.fields definition. form_class type[ModelForm] Optional. Can be used instead of serializer_class . output_form_class type[ModelForm] Optional. Can be used instead of output_serializer_class Custom mutations \ud83d\udd17 Custom mutations can be created by subclassing DjangoMutation and implementing the custom_mutation method. serializer_class and output_serializer_class can be set in the Meta -class, and will be converted to the mutation's input and output types. If output_serializer_class is not set, serializer_class will be used for both input and output types. from graphene_django_extensions.bases import DjangoMutation class ExampleCustomMutation ( DjangoMutation ): class Meta : serializer_class = ExampleInputSerializer output_serializer_class = ExampleOutputSerializer @classmethod def custom_mutation ( cls , info , ** kwargs ): # Do custom logic here. # `kwargs` have already been validated by the serializer. return cls ( ... ) Like model mutations, form_class and output_form_class can be used instead of serializer_class and output_serializer_class . NestingModelSerializer \ud83d\udd17 A custom ModelSerializer that contains logic for updating and creating related models when they are included as nested serializer fields: from graphene_django_extensions import NestingModelSerializer class SubSerializer ( NestingModelSerializer ): class Meta : model = Sub fields = [ \"pk\" , \"sub_field\" ] class MainSerializer ( NestingModelSerializer ): sub_entry = SubSerializer () class Meta : model = Main fields = [ \"pk\" , \"main_field\" , \"sub_entry\" ] When using the above serializers with the following data: { \"main_field\" : \"foo\" , \"sub_entities\" : { \"sub_field\" : \"bar\" } } This will create the Main entity and the Sub entity, and link the Sub entity to the Main entity. If instead this is used: { \"pk\" : 1 , \"sub_entities\" : { \"sub_field\" : \"bar\" } } This will update the Main entity with pk=1 , and create a new Sub entity and link it to the Main entity. We can also link an existing Sub entity to the Main entity on update or create: { \"main_field\" : \"foo\" , \"sub_entities\" : { \"pk\" : 2 } } If the Sub entity does not exist, a 404 error will be raised. If the sub entity is already linked to another Main entity, this will be a no-op. If the pk field is included in the subquery, the existing Sub entity will be updated: { \"main_field\" : \"foo\" , \"sub_entities\" : { \"pk\" : 2 , \"sub_field\" : \"value\" } } For to_many relations, the serializer field must use many=True : class MainSerializer ( NestingModelSerializer ): sub_entry = SubSerializer ( many = True ) Same logic applies for to_many relations, but if the relation is a one_to_many relation, and the relation is updated, any existing related entities that were not included in the request will be deleted (e.g. Sub entity with pk=1 could have been deleted here): { \"pk\" : 1 , \"sub_entities\" : [ { \"pk\" : 2 }, { \"sub_field\" : \"value\" } ] }","title":"Mutations"},{"location":"mutations/#mutations","text":"","title":"Mutations"},{"location":"mutations/#djangomutation","text":"Custom base class for GraphQL-mutations that are backed by a Django model. Has three subclasses: CreateMutation , UpdateMutation and DeleteMutation , which should cover most use cases, but custom mutations can also be created. from graphene_django_extensions import CreateMutation , UpdateMutation , DeleteMutation class ExampleCreateMutation ( CreateMutation ): class Meta : model = Example serializer_class = ExampleSerializer class ExampleUpdateMutation ( UpdateMutation ): class Meta : model = Example serializer_class = ExampleSerializer class ExampleDeleteMutation ( DeleteMutation ): class Meta : model = Example Adds the following features to all types that inherit it: For update operations, converts all fields to optional fields, enabling partial updates. Can add permission checks via permission classes. Converts and formats errors raised from serializers (also nested ones) into GraphQL errors. Checks for missing object types for nested model serializer fields to avoid nebulous import order errors.","title":"DjangoMutation"},{"location":"mutations/#permission-errors","text":"If a permission check for a mutation fails, an error like this will be raised: { \"errors\" : [ { \"message\" : \"No permission to create.\" , \"path\" : [ \"createExample\" ], \"extensions\" : { \"code\" : \"CREATE_PERMISSION_DENIED\" }, \"locations\" : [{ \"line\" : 1 , \"column\" : 63 }] } ] } The message and code depends on the operation type, and can be changed using the following settings. Operation Message setting Message default Code setting Code default create CREATE_PERMISSION_ERROR_MESSAGE No permission to create. CREATE_PERMISSION_ERROR_CODE CREATE_PERMISSION_DENIED update UPDATE_PERMISSION_ERROR_MESSAGE No permission to update. UPDATE_PERMISSION_ERROR_CODE UPDATE_PERMISSION_DENIED delete DELETE_PERMISSION_ERROR_MESSAGE No permission to delete. DELETE_PERMISSION_ERROR_CODE DELETE_PERMISSION_DENIED custom MUTATION_PERMISSION_ERROR_MESSAGE No permission to mutate. MUTATION_PERMISSION_ERROR_CODE MUTATION_PERMISSION_DENIED More on permissions on the permissions page .","title":"Permission errors"},{"location":"mutations/#field-level-errors","text":"If a mutation serializer raises a ValidationError , the errors will be converted into a single GraphQL error with all the individual field error messages and codes included: { \"errors\" : [ { \"message\" : \"Mutation was unsuccessful.\" , \"path\" : [ \"createExample\" ], \"extensions\" : { \"code\" : \"MUTATION_VALIDATION_ERROR\" , \"errors\" : [ { \"field\" : \"number\" , \"message\" : \"Number must be positive.\" , \"code\" : \"invalid\" }, { \"field\" : \"number\" , \"message\" : \"Number must be an even.\" , \"code\" : \"\" }, { \"field\" : \"text\" , \"message\" : \"Text must be at least 10 characters long.\" , \"code\" : \"invalid\" } ] }, \"locations\" : [{ \"line\" : 1 , \"column\" : 63 }] } ] } If the error is raised from a nested serializer (when creating sub entities along with the parent entity, see NestingModelSerializer below), the field will include the dotted path to the sub entity where the field is located: { \"errors\" : [ { \"message\" : \"Mutation was unsuccessful.\" , \"path\" : [ \"createExample\" ], \"extensions\" : { \"code\" : \"MUTATION_VALIDATION_ERROR\" , \"errors\" : [ { \"field\" : \"subEntry.number\" , \"message\" : \"Number must be positive.\" , \"code\" : \"invalid\" } ] }, \"locations\" : [{ \"line\" : 1 , \"column\" : 63 }] } ] } The following options can be set in the Meta -class. Option Type Description model type[Model] Required (delete only). Model class for the model the operation is performed on. serializer_class type[ModelSerializer] Required (create and update only). The serializer used for the mutation. output_serializer_class type[ModelSerializer] Optional. The serializer used for the output data. If not set, serializer_class is used. Serializer fields are modified so that all fields are optional, enabling partial updates. permission_classes list[type[BasePermission]] Optional. Set permission classes for the mutation. Defaults to ( AllowAny ,). lookup_field str Optional. The field used for looking up the instance to be mutated. Defaults to the object's primary key, which is usually id . Note that the lookup_field attribute has to be available from the serializer's Meta.fields definition. form_class type[ModelForm] Optional. Can be used instead of serializer_class . output_form_class type[ModelForm] Optional. Can be used instead of output_serializer_class","title":"Field level errors"},{"location":"mutations/#custom-mutations","text":"Custom mutations can be created by subclassing DjangoMutation and implementing the custom_mutation method. serializer_class and output_serializer_class can be set in the Meta -class, and will be converted to the mutation's input and output types. If output_serializer_class is not set, serializer_class will be used for both input and output types. from graphene_django_extensions.bases import DjangoMutation class ExampleCustomMutation ( DjangoMutation ): class Meta : serializer_class = ExampleInputSerializer output_serializer_class = ExampleOutputSerializer @classmethod def custom_mutation ( cls , info , ** kwargs ): # Do custom logic here. # `kwargs` have already been validated by the serializer. return cls ( ... ) Like model mutations, form_class and output_form_class can be used instead of serializer_class and output_serializer_class .","title":"Custom mutations"},{"location":"mutations/#nestingmodelserializer","text":"A custom ModelSerializer that contains logic for updating and creating related models when they are included as nested serializer fields: from graphene_django_extensions import NestingModelSerializer class SubSerializer ( NestingModelSerializer ): class Meta : model = Sub fields = [ \"pk\" , \"sub_field\" ] class MainSerializer ( NestingModelSerializer ): sub_entry = SubSerializer () class Meta : model = Main fields = [ \"pk\" , \"main_field\" , \"sub_entry\" ] When using the above serializers with the following data: { \"main_field\" : \"foo\" , \"sub_entities\" : { \"sub_field\" : \"bar\" } } This will create the Main entity and the Sub entity, and link the Sub entity to the Main entity. If instead this is used: { \"pk\" : 1 , \"sub_entities\" : { \"sub_field\" : \"bar\" } } This will update the Main entity with pk=1 , and create a new Sub entity and link it to the Main entity. We can also link an existing Sub entity to the Main entity on update or create: { \"main_field\" : \"foo\" , \"sub_entities\" : { \"pk\" : 2 } } If the Sub entity does not exist, a 404 error will be raised. If the sub entity is already linked to another Main entity, this will be a no-op. If the pk field is included in the subquery, the existing Sub entity will be updated: { \"main_field\" : \"foo\" , \"sub_entities\" : { \"pk\" : 2 , \"sub_field\" : \"value\" } } For to_many relations, the serializer field must use many=True : class MainSerializer ( NestingModelSerializer ): sub_entry = SubSerializer ( many = True ) Same logic applies for to_many relations, but if the relation is a one_to_many relation, and the relation is updated, any existing related entities that were not included in the request will be deleted (e.g. Sub entity with pk=1 could have been deleted here): { \"pk\" : 1 , \"sub_entities\" : [ { \"pk\" : 2 }, { \"sub_field\" : \"value\" } ] }","title":"NestingModelSerializer"},{"location":"permissions/","text":"Permissions \ud83d\udd17 Permissions classes \ud83d\udd17 Implements graphene-permissions style permission classes. These methods can be overridden in subclasses to implement custom permissions: has_permission \ud83d\udd17 args: user: User | AnonymousUser This is the main method for checking permissions. has_node_permission , has_filter_permission , and has_mutation_permission will default to this if not overridden. has_node_permission \ud83d\udd17 args: instance: Model user: User | AnonymousUser filters: dict[str, Any] Override this method to add specific permissions to a node field defined for a DjangoNode . has_filter_permission \ud83d\udd17 args: user: User | AnonymousUser filters: dict[str, Any] Override this method to add specific permissions to a list or connections fields defined for a DjangoNode . has_mutation_permission \ud83d\udd17 args: user: User | AnonymousUser input_data: dict[str, Any] Override this method to add specific permissions to all mutations. has_create_permission , has_update_permission , and has_delete_permission will default to this if not overridden. has_create_permission \ud83d\udd17 args: user: User | AnonymousUser input_data: dict[str, Any] Override this method to add specific permissions to a create mutation defined by CreateMutation . has_update_permission \ud83d\udd17 args: instance: Model user: User | AnonymousUser input_data: dict[str, Any] Override this method to add specific permissions to an update mutation defined by UpdateMutation . has_delete_permission \ud83d\udd17 args: instance: Model user: User | AnonymousUser input_data: dict[str, Any] Override this method to add specific permissions to a delete mutation defined by DeleteMutation . Restricted fields \ud83d\udd17 To add more fine-grained permissions to individual fields, the restricted_field decorator can be used on field resolvers. This will perform the permission check before the resolver is called, and raise an exception if the permission check fails. There are two allowed interfaces for permissions checks: def permission_check ( user : User | AnonymousUser ) -> bool : ... or def permission_check ( user : User | AnonymousUser , instance : Model ) -> bool : ... ...where the instance is the instance of the model that the field resolver is being called on. When using DjangoNode , the Meta.restricted_fields option can be used to add permission checks without having to use the decorator on each field resolver. from graphene_django_extensions import DjangoNode from graphene_django_extensions.permissions import restricted_field class ExampleNode ( DjangoNode ): class Meta : model = Example fields = [ \"example_field\" ] # Option 1 restricted_fields = { \"example_field\" : lambda user : user . is_authenticated , } # Option 2 @restricted_field ( lambda user : user . is_authenticated ) def resolve_example_field ( root : Example , info : GQLInfo ): return root . example_field Field permissions will return errors in the following format: { \"errors\" : [ { \"message\" : \"No permission to access field.\" , \"path\" : [ \"examples\" , \"edges\" , 0 , \"node\" , \"email\" ], \"extensions\" : { \"code\" : \"FIELD_PERMISSION_DENIED\" }, \"locations\" : [{ \"column\" : 38 , \"line\" : 1 }] } ] } The message and code can be changed using the following settings: Message setting Message default Code setting Code default FIELD_PERMISSION_ERROR_MESSAGE No permission to access field. FIELD_PERMISSION_ERROR_CODE FIELD_PERMISSION_DENIED","title":"Permissions"},{"location":"permissions/#permissions","text":"","title":"Permissions"},{"location":"permissions/#permissions-classes","text":"Implements graphene-permissions style permission classes. These methods can be overridden in subclasses to implement custom permissions:","title":"Permissions classes"},{"location":"permissions/#has_permission","text":"args: user: User | AnonymousUser This is the main method for checking permissions. has_node_permission , has_filter_permission , and has_mutation_permission will default to this if not overridden.","title":"has_permission"},{"location":"permissions/#has_node_permission","text":"args: instance: Model user: User | AnonymousUser filters: dict[str, Any] Override this method to add specific permissions to a node field defined for a DjangoNode .","title":"has_node_permission"},{"location":"permissions/#has_filter_permission","text":"args: user: User | AnonymousUser filters: dict[str, Any] Override this method to add specific permissions to a list or connections fields defined for a DjangoNode .","title":"has_filter_permission"},{"location":"permissions/#has_mutation_permission","text":"args: user: User | AnonymousUser input_data: dict[str, Any] Override this method to add specific permissions to all mutations. has_create_permission , has_update_permission , and has_delete_permission will default to this if not overridden.","title":"has_mutation_permission"},{"location":"permissions/#has_create_permission","text":"args: user: User | AnonymousUser input_data: dict[str, Any] Override this method to add specific permissions to a create mutation defined by CreateMutation .","title":"has_create_permission"},{"location":"permissions/#has_update_permission","text":"args: instance: Model user: User | AnonymousUser input_data: dict[str, Any] Override this method to add specific permissions to an update mutation defined by UpdateMutation .","title":"has_update_permission"},{"location":"permissions/#has_delete_permission","text":"args: instance: Model user: User | AnonymousUser input_data: dict[str, Any] Override this method to add specific permissions to a delete mutation defined by DeleteMutation .","title":"has_delete_permission"},{"location":"permissions/#restricted-fields","text":"To add more fine-grained permissions to individual fields, the restricted_field decorator can be used on field resolvers. This will perform the permission check before the resolver is called, and raise an exception if the permission check fails. There are two allowed interfaces for permissions checks: def permission_check ( user : User | AnonymousUser ) -> bool : ... or def permission_check ( user : User | AnonymousUser , instance : Model ) -> bool : ... ...where the instance is the instance of the model that the field resolver is being called on. When using DjangoNode , the Meta.restricted_fields option can be used to add permission checks without having to use the decorator on each field resolver. from graphene_django_extensions import DjangoNode from graphene_django_extensions.permissions import restricted_field class ExampleNode ( DjangoNode ): class Meta : model = Example fields = [ \"example_field\" ] # Option 1 restricted_fields = { \"example_field\" : lambda user : user . is_authenticated , } # Option 2 @restricted_field ( lambda user : user . is_authenticated ) def resolve_example_field ( root : Example , info : GQLInfo ): return root . example_field Field permissions will return errors in the following format: { \"errors\" : [ { \"message\" : \"No permission to access field.\" , \"path\" : [ \"examples\" , \"edges\" , 0 , \"node\" , \"email\" ], \"extensions\" : { \"code\" : \"FIELD_PERMISSION_DENIED\" }, \"locations\" : [{ \"column\" : 38 , \"line\" : 1 }] } ] } The message and code can be changed using the following settings: Message setting Message default Code setting Code default FIELD_PERMISSION_ERROR_MESSAGE No permission to access field. FIELD_PERMISSION_ERROR_CODE FIELD_PERMISSION_DENIED","title":"Restricted fields"},{"location":"querying/","text":"Queries \ud83d\udd17 DjangoNode \ud83d\udd17 Custom base class for GraphQL ObjectTypes that are backed by a Django model. from graphene_django_extensions import DjangoNode from example.models import Example class MyNode ( DjangoNode ): class Meta : model = Example fields = [ ... ] Extends graphene_django.types.DjangoObjectType and adds the following features: Makes the graphene.relay.Node interface the default interface for the type. Adds total_count = graphene.Int() field to the default Connection field for the type. Adds pk primary key field and resolver to the ObjectType, if present in Meta.fields . Can add permission checks via permission classes. Permission errors \ud83d\udd17 If a permission check for a query fails, an error like this will be raised: { \"errors\" : [ { \"message\" : \"No permission to access node.\" , \"path\" : [ \"examples\" ], \"extensions\" : { \"code\" : \"NODE_PERMISSION_DENIED\" }, \"locations\" : [{ \"line\" : 1 , \"column\" : 63 }] } ] } The message and code depends on the operation type, and can be changed using the following settings. Operation Message setting Message default Code setting Code default field / node QUERY_PERMISSION_ERROR_MESSAGE No permission to access node. QUERY_PERMISSION_ERROR_CODE NODE_PERMISSION_DENIED list / connection FILTER_PERMISSION_ERROR_MESSAGE No permission to access node. FILTER_PERMISSION_ERROR_CODE FILTER_PERMISSION_DENIED More on permissions on the permissions page . Interface \ud83d\udd17 Some new methods are also added. Here are the most useful ones: filter_queryset \ud83d\udd17 args: queryset: QuerySet info: GQLInfo Can be used to filter available rows for both get_queryset and get_node . Use this instead of get_queryset for filtering, since the built-in SQL optimizer is able to include these in the query plan. Field \ud83d\udd17 args: kwargs: dict[str, Any] Create a 'regular' Field from the type. RelatedField \ud83d\udd17 args: kwargs: dict[str, Any] Create a one-to-one or many-to-one related Field from the type. ListField \ud83d\udd17 args: kwargs: dict[str, Any] Create a DjangoListField from the type. Node \ud83d\udd17 args: kwargs: dict[str, Any] Create a Relay Node from the type. Connection \ud83d\udd17 args: kwargs: dict[str, Any] Create a Relay Connection Field from the type. Subclasses can be configured through the Meta -class. Here are the most useful options: Option Type Description model type[Model] Required. The model class for the node. fields list[str] or __all__ Required. The fields to include in the node. If __all__ is used, all fields are included. filterset_class type[FilterSet] Optional. The FilterSet class to use for filtering the ObjectType queryset. permission_classes list[type[BasePermission]] Optional. Set permission classes for the node. Defaults to ( AllowAny ,). restricted_fields dict[str, PermCheck] Optional. Adds permission checks to the resolvers of the fields as defined in the dict.","title":"Querying"},{"location":"querying/#queries","text":"","title":"Queries"},{"location":"querying/#djangonode","text":"Custom base class for GraphQL ObjectTypes that are backed by a Django model. from graphene_django_extensions import DjangoNode from example.models import Example class MyNode ( DjangoNode ): class Meta : model = Example fields = [ ... ] Extends graphene_django.types.DjangoObjectType and adds the following features: Makes the graphene.relay.Node interface the default interface for the type. Adds total_count = graphene.Int() field to the default Connection field for the type. Adds pk primary key field and resolver to the ObjectType, if present in Meta.fields . Can add permission checks via permission classes.","title":"DjangoNode"},{"location":"querying/#permission-errors","text":"If a permission check for a query fails, an error like this will be raised: { \"errors\" : [ { \"message\" : \"No permission to access node.\" , \"path\" : [ \"examples\" ], \"extensions\" : { \"code\" : \"NODE_PERMISSION_DENIED\" }, \"locations\" : [{ \"line\" : 1 , \"column\" : 63 }] } ] } The message and code depends on the operation type, and can be changed using the following settings. Operation Message setting Message default Code setting Code default field / node QUERY_PERMISSION_ERROR_MESSAGE No permission to access node. QUERY_PERMISSION_ERROR_CODE NODE_PERMISSION_DENIED list / connection FILTER_PERMISSION_ERROR_MESSAGE No permission to access node. FILTER_PERMISSION_ERROR_CODE FILTER_PERMISSION_DENIED More on permissions on the permissions page .","title":"Permission errors"},{"location":"querying/#interface","text":"Some new methods are also added. Here are the most useful ones:","title":"Interface"},{"location":"querying/#filter_queryset","text":"args: queryset: QuerySet info: GQLInfo Can be used to filter available rows for both get_queryset and get_node . Use this instead of get_queryset for filtering, since the built-in SQL optimizer is able to include these in the query plan.","title":"filter_queryset"},{"location":"querying/#field","text":"args: kwargs: dict[str, Any] Create a 'regular' Field from the type.","title":"Field"},{"location":"querying/#relatedfield","text":"args: kwargs: dict[str, Any] Create a one-to-one or many-to-one related Field from the type.","title":"RelatedField"},{"location":"querying/#listfield","text":"args: kwargs: dict[str, Any] Create a DjangoListField from the type.","title":"ListField"},{"location":"querying/#node","text":"args: kwargs: dict[str, Any] Create a Relay Node from the type.","title":"Node"},{"location":"querying/#connection","text":"args: kwargs: dict[str, Any] Create a Relay Connection Field from the type. Subclasses can be configured through the Meta -class. Here are the most useful options: Option Type Description model type[Model] Required. The model class for the node. fields list[str] or __all__ Required. The fields to include in the node. If __all__ is used, all fields are included. filterset_class type[FilterSet] Optional. The FilterSet class to use for filtering the ObjectType queryset. permission_classes list[type[BasePermission]] Optional. Set permission classes for the node. Defaults to ( AllowAny ,). restricted_fields dict[str, PermCheck] Optional. Adds permission checks to the resolvers of the fields as defined in the dict.","title":"Connection"},{"location":"testing/","text":"Testing tools \ud83d\udd17 build_query \ud83d\udd17 args: __name : Name of the query, in camelCase. fields : Field selections as a GraphQL string. connection : Whether to build a Relay Connection query or basic one. **filter_params : Parameters to use in the query. Will be converted to camelCase. Use __ to add filters to fields instead of the query. Used to build GraphQL queries for testing. build_mutation \ud83d\udd17 args: __name : Name of the mutation, in camelCase. __mutation_class_name : Name of the mutation ObjectType, in PascalCase. fields : Field selections as a GraphQL string. Used to build GraphQL mutations for testing. GraphQLClient \ud83d\udd17 Testing client with a convenient response object and database query counting. Can be accessed through graphql fixture.","title":"Testing"},{"location":"testing/#testing-tools","text":"","title":"Testing tools"},{"location":"testing/#build_query","text":"args: __name : Name of the query, in camelCase. fields : Field selections as a GraphQL string. connection : Whether to build a Relay Connection query or basic one. **filter_params : Parameters to use in the query. Will be converted to camelCase. Use __ to add filters to fields instead of the query. Used to build GraphQL queries for testing.","title":"build_query"},{"location":"testing/#build_mutation","text":"args: __name : Name of the mutation, in camelCase. __mutation_class_name : Name of the mutation ObjectType, in PascalCase. fields : Field selections as a GraphQL string. Used to build GraphQL mutations for testing.","title":"build_mutation"},{"location":"testing/#graphqlclient","text":"Testing client with a convenient response object and database query counting. Can be accessed through graphql fixture.","title":"GraphQLClient"}]}